package com.example.testc2.basics.threads;

import android.util.Log;


/**
 *
 * synchronized：
 *  ... monitor-enter
 *  ...
 *  ... monitor-exit
 *
 *
 *
 *    https://www.cnblogs.com/hongdada/p/14087177.html
 *
 *
 *
 *  1 对象头
 *  1.1  Mark Word
 *
 *  32位 hotspot
 * |-------------------------------------------------------|--------------------|
 * |                  Mark Word (32 bits)                  |       State        |
 * |-------------------------------------------------------|--------------------|
 * | identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |
 * |-------------------------------------------------------|--------------------|
 * |  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |       Biased       |
 * |-------------------------------------------------------|--------------------|
 * |               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |
 * |-------------------------------------------------------|--------------------|
 * |               ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |
 * |-------------------------------------------------------|--------------------|
 * |                                              | lock:2 |    Marked for GC   |
 * |-------------------------------------------------------|--------------------|
 *
 *
 * lock:2位的锁状态标记位，由于希望用尽可能少的二进制位表示尽可能多的信息，所以设置了lock标记。
 *
 * biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。
 *
 * age：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。
 *
 * identity_hashcode：25位的对象标识Hash码，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。
 *
 * thread：持有偏向锁的线程ID。
 *
 *
 *
 *
 *  1.2  类型指针
 *
 *  类型指针（Klass Word）#
 *
 * 类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例。
 * 这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。
 *
 *
 * ------  数组长度
 *
 * 数组长度（Array Length）#
 *
 * 如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度。
 *
 * 这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。
 *
 * 64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。
 *
 *
 *  2 实例数据
 *
 *  3 对齐填充 ： 由于虚拟机要求对象起始地址必须是8字节的整数倍，对齐填充**仅仅是为了使字节对齐。
 *
 *
 *----------------------------------------------------------------------------------------------------------------------
 *
 * 2.1 Synchronized三种锁#
 *
 * Java对象的锁状态一共有四种，级别从低到高依次为: 无锁(01) -> 偏向锁(01) -> 轻量级锁(00) -> 重量级锁(10).
 *
 *
 * 2.1.1 偏向锁#
 *
 * 引入偏向锁的主要原因是，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。
 *
 * 2.1.2  重量级锁#
 *
 * 重量级锁依赖对象内部的monitor锁来实现，而monitor又依赖操作系统的MutexLock（互斥锁）
 *
 * Mutex变量的值为1，表示互斥锁空闲，这个时候某个线程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被其他线程获得，其他线程调用lock只能挂起等待
 * 获取锁时,锁对象的Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。
 * 我们经常看见的synchronized就是非常典型的重量级锁，通过指令moniter enter 加锁，moniter exit解锁。
 *
 * 为什么重量级锁开销比较大#
 * 原因是当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现，也就是相当于从用户态转化到内核态，而转化状态是需要消耗时间的
 *
 *----------------------------------------------------------------------------------------------------------------------
 *
 *
 *
 * ---------------
 *
 *
 *
 *
 *
 */
public class Test1 {

    public static void test1(){
        Object lock = new Object();
        int h1 = lock.hashCode();
        Log.d("testt1","h1:"+h1);
        synchronized (lock){
            int h2 = lock.hashCode();
            Log.d("testt1","h2:"+h2);
        }
    }

}
