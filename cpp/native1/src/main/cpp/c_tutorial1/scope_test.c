//
// Created by wei wang on 2022-02-10.
//

/**
     * 进阶篇（八）
     * https://cloud.tencent.com/developer/article/1460518?from=article.detail.1450925

gcc scope_test.c -o scope
gcc scope_test.c t1.c -o scope


局部变量

局部变量是指在某个函数内部声明的变量。它有两个含义

在某个函数内声明的局部变量，不能被其他的函数使用，意即只在声明它的函数内有效。
每次调用函数时，生成的局部变量的储存空间可能都是不同的，意即局部变量在函数调用结束后，就会释放，下次调用函数，生成的局部变量又是一个新的。
还要注意一点，在函数的形式参数中声明的变量，也都是局部变量。




 全局变量

与局部变量相对的概念是全局变量，它声明在所有的函数体之外。全局变量在文件作用域内可见，即从变量被声明的下一行，一直到当前文件的末尾，它都可以被直接使用，因此全局变量可以被它之后定义的所有函数访问。

需要注意一点，编译器会自动将全局变量进行零值初始化。因此在使用时，只需要声明即可。如果需要手动指定其值进行初始化，则它只能被常量表达式初始化，使用其他的变量表达式初始化是不合法的。





 static关键字

除了局部变量和全局变量，C语言中还有静态局部变量和静态全局变量，声明时使用static关键字修饰即代表静态的意思。


 静态全局变量和普通全局变量的区别不是很大，主要体现在访问权限的区别上。在C语言中，全局变量是在整个程序的生命期中都有效的，换句话说，也就是一旦声明了一个全局变量，
 则整个程序中都可以访问，而静态全局变量，则只在声明它的那个源文件中可以访问。



静态局部变量和普通局部变量的区别就比较大了，主要有三个区别

存储位置不同。静态局部变量被编译器放在全局存储区，虽是局部变量，但是在程序的整个生命期中都存在。而普通局部变量在函数调用结束后就会被释放。从这一点上看，静态局部变量和全局变量被放在了相同的储存位置。
静态局部变量会被编译器自动初始化为零值。我们都知道普通局部变量的原则是先初始化后使用，而静态局部变量则和全局变量一样，会被自动初始化，使用时只需声明，无需手动初始化。
静态局部变量只能被声明它的函数访问。静态局部变量与普通局部变量的访问权限相同，都只能被声明它的函数使用。如上例，静态局部变量count只能被get_count函数使用，即使count变量在整个程序的生命期中都有效，其他函数也无法使用它。



说完了静态局部变量后，大家肯定疑惑，既然它只在声明它的函数中使用，那它还有什么意义呢？直接使用普通局部变量不就行了，干嘛要用它？
 我们知道，普通局部变量在函数每次被调用的时候都会生成一个新的，调用结束后又将它释放，如果一个函数被频繁调用，这样性能岂不是很低？
 因为需要不停的生成新的局部变量，然后又释放掉，然后又生成新的……但是给局部变量加上了static修饰后，函数无论被调用多少次，都不会再生成新的局部变量，始终都是复用的同一个变量，
 这就大大减少了对内存的操作，提升了性能。


静态函数static关键字除了可以修饰变量，还可以用来修饰函数。在C++、Java等面向对象的编程语言中，都存在类似于private的权限访问控制，
 而C语言中的static关键字，就类似这种private，被它修饰的函数只能在当前源文件中使用，在其他源文件中无法被访问。
 通常来说，C语言编写的大型的模块化工程中，不需要共享的函数都应该使用static关键字来修饰。


 extern
当全局变量离开了它的文件作用域后，无法直接使用，这时候我们需要另一个关键字extern来帮助我们使用它。

--------------------------------------------------------------------------------
 小拓展
 有时候我们可能会看到extern “C”这样的声明，请注意，这不是C语言的语法，也不属于C语言。有些C++程序员，经常把C语言和C++语言搞混，实际上这是两种不同的语言，
 C++也并不是很多人说的那样，完全是C语言的超集，更准确的说法应该是，C++是一种独立的语言，它兼容C语言的绝大多数语法，但并不是百分百完全兼容。
 C++除了兼容的C语言的语法，另一部分就是它独立的内容。如果不能完全清楚这两种语言的边界，就会发生语法弄混的情况。

在C++中，当需要调用纯C语言编写的函数时，通常会使用extern “C”声明，表明这是纯C语言的内容。
 --------------------------------------------------------------------------------


 模块化开发的补充

头文件的嵌套包含/头文件的保护

所谓嵌套包含，就是指在一个头文件中，还可以使用#include预编译指令，包含其他的头文件。例如，我们编写一个头文件bool.h
如果一个源文件将同一个头文件包含两次，那么就可能会产生编译错误。


问题出来了，该如何解决呢？在复杂的大型工程中，头文件被重复包含的问题一定是避免不了的，这个时候就需要我们上一章讲的条件编译知识出来救场了。


// 如果没有定义过_H_H3_ 宏，则定义一个_H_H3_ 宏
#ifndef _H_H3_
#define _H_H3_
// 声明的内容 ……
#endif


 */

#include <stdio.h>


//全局变量(正确)
int minute = 360 -10;

//错误!!! 全局变量必须使用常量表达式初始化
//int hour = minute/60;


int get_count(){
    // 静态局部变量
    static int count;
    count++;
    return count;
}


int main() {
    printf("%d\n",get_count());
    printf("%d\n",get_count());
    printf("%d\n",get_count());
    printf("%d\n",get_count());

    //在这里，extern int s_global;并不是重新声明变量的意思，它表示的是引用全局变量s_global，
    // 一定要注意，如果不存在一个全局变量s_global，是无法编译的，也就是说，使用extern来引用全局变量时，全局变量一定要存在。
    //  否则编译爆  --》 Undefined symbols for architecture x86_64:   .......  symbol(s) not found for architecture x86_64
    extern int s_global;  //
    printf("s_global = %d\n", s_global);  //  error: use of undeclared identifier 's_global'
    return 0;
}
